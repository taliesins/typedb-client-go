// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package grakn_protocol

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// GraknCoreClient is the client API for GraknCore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GraknCoreClient interface {
	// Database Manager API
	DatabasesContains(ctx context.Context, in *CoreDatabaseManager_Contains_Req, opts ...grpc.CallOption) (*CoreDatabaseManager_Contains_Res, error)
	DatabasesCreate(ctx context.Context, in *CoreDatabaseManager_Create_Req, opts ...grpc.CallOption) (*CoreDatabaseManager_Create_Res, error)
	DatabasesAll(ctx context.Context, in *CoreDatabaseManager_All_Req, opts ...grpc.CallOption) (*CoreDatabaseManager_All_Res, error)
	// Database API
	DatabaseSchema(ctx context.Context, in *CoreDatabase_Schema_Req, opts ...grpc.CallOption) (*CoreDatabase_Schema_Res, error)
	DatabaseDelete(ctx context.Context, in *CoreDatabase_Delete_Req, opts ...grpc.CallOption) (*CoreDatabase_Delete_Res, error)
	// Session API
	SessionOpen(ctx context.Context, in *Session_Open_Req, opts ...grpc.CallOption) (*Session_Open_Res, error)
	SessionClose(ctx context.Context, in *Session_Close_Req, opts ...grpc.CallOption) (*Session_Close_Res, error)
	// Checks with the server that the session is still alive, and informs it that it should be kept alive.
	SessionPulse(ctx context.Context, in *Session_Pulse_Req, opts ...grpc.CallOption) (*Session_Pulse_Res, error)
	// Transaction Streaming API
	// Opens a bi-directional stream representing a stateful transaction, streaming
	// requests and responses back-and-forth. The first transaction client message must
	// be {Transaction.Open.Req}. Closing the stream closes the transaction.
	Transaction(ctx context.Context, opts ...grpc.CallOption) (GraknCore_TransactionClient, error)
}

type graknCoreClient struct {
	cc grpc.ClientConnInterface
}

func NewGraknCoreClient(cc grpc.ClientConnInterface) GraknCoreClient {
	return &graknCoreClient{cc}
}

func (c *graknCoreClient) DatabasesContains(ctx context.Context, in *CoreDatabaseManager_Contains_Req, opts ...grpc.CallOption) (*CoreDatabaseManager_Contains_Res, error) {
	out := new(CoreDatabaseManager_Contains_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/databases_contains", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) DatabasesCreate(ctx context.Context, in *CoreDatabaseManager_Create_Req, opts ...grpc.CallOption) (*CoreDatabaseManager_Create_Res, error) {
	out := new(CoreDatabaseManager_Create_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/databases_create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) DatabasesAll(ctx context.Context, in *CoreDatabaseManager_All_Req, opts ...grpc.CallOption) (*CoreDatabaseManager_All_Res, error) {
	out := new(CoreDatabaseManager_All_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/databases_all", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) DatabaseSchema(ctx context.Context, in *CoreDatabase_Schema_Req, opts ...grpc.CallOption) (*CoreDatabase_Schema_Res, error) {
	out := new(CoreDatabase_Schema_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/database_schema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) DatabaseDelete(ctx context.Context, in *CoreDatabase_Delete_Req, opts ...grpc.CallOption) (*CoreDatabase_Delete_Res, error) {
	out := new(CoreDatabase_Delete_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/database_delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) SessionOpen(ctx context.Context, in *Session_Open_Req, opts ...grpc.CallOption) (*Session_Open_Res, error) {
	out := new(Session_Open_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/session_open", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) SessionClose(ctx context.Context, in *Session_Close_Req, opts ...grpc.CallOption) (*Session_Close_Res, error) {
	out := new(Session_Close_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/session_close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) SessionPulse(ctx context.Context, in *Session_Pulse_Req, opts ...grpc.CallOption) (*Session_Pulse_Res, error) {
	out := new(Session_Pulse_Res)
	err := c.cc.Invoke(ctx, "/grakn.protocol.GraknCore/session_pulse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graknCoreClient) Transaction(ctx context.Context, opts ...grpc.CallOption) (GraknCore_TransactionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GraknCore_serviceDesc.Streams[0], "/grakn.protocol.GraknCore/transaction", opts...)
	if err != nil {
		return nil, err
	}
	x := &graknCoreTransactionClient{stream}
	return x, nil
}

type GraknCore_TransactionClient interface {
	Send(*Transaction_Client) error
	Recv() (*Transaction_Server, error)
	grpc.ClientStream
}

type graknCoreTransactionClient struct {
	grpc.ClientStream
}

func (x *graknCoreTransactionClient) Send(m *Transaction_Client) error {
	return x.ClientStream.SendMsg(m)
}

func (x *graknCoreTransactionClient) Recv() (*Transaction_Server, error) {
	m := new(Transaction_Server)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GraknCoreServer is the server API for GraknCore service.
// All implementations must embed UnimplementedGraknCoreServer
// for forward compatibility
type GraknCoreServer interface {
	// Database Manager API
	DatabasesContains(context.Context, *CoreDatabaseManager_Contains_Req) (*CoreDatabaseManager_Contains_Res, error)
	DatabasesCreate(context.Context, *CoreDatabaseManager_Create_Req) (*CoreDatabaseManager_Create_Res, error)
	DatabasesAll(context.Context, *CoreDatabaseManager_All_Req) (*CoreDatabaseManager_All_Res, error)
	// Database API
	DatabaseSchema(context.Context, *CoreDatabase_Schema_Req) (*CoreDatabase_Schema_Res, error)
	DatabaseDelete(context.Context, *CoreDatabase_Delete_Req) (*CoreDatabase_Delete_Res, error)
	// Session API
	SessionOpen(context.Context, *Session_Open_Req) (*Session_Open_Res, error)
	SessionClose(context.Context, *Session_Close_Req) (*Session_Close_Res, error)
	// Checks with the server that the session is still alive, and informs it that it should be kept alive.
	SessionPulse(context.Context, *Session_Pulse_Req) (*Session_Pulse_Res, error)
	// Transaction Streaming API
	// Opens a bi-directional stream representing a stateful transaction, streaming
	// requests and responses back-and-forth. The first transaction client message must
	// be {Transaction.Open.Req}. Closing the stream closes the transaction.
	Transaction(GraknCore_TransactionServer) error
	mustEmbedUnimplementedGraknCoreServer()
}

// UnimplementedGraknCoreServer must be embedded to have forward compatible implementations.
type UnimplementedGraknCoreServer struct {
}

func (UnimplementedGraknCoreServer) DatabasesContains(context.Context, *CoreDatabaseManager_Contains_Req) (*CoreDatabaseManager_Contains_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabasesContains not implemented")
}
func (UnimplementedGraknCoreServer) DatabasesCreate(context.Context, *CoreDatabaseManager_Create_Req) (*CoreDatabaseManager_Create_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabasesCreate not implemented")
}
func (UnimplementedGraknCoreServer) DatabasesAll(context.Context, *CoreDatabaseManager_All_Req) (*CoreDatabaseManager_All_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabasesAll not implemented")
}
func (UnimplementedGraknCoreServer) DatabaseSchema(context.Context, *CoreDatabase_Schema_Req) (*CoreDatabase_Schema_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseSchema not implemented")
}
func (UnimplementedGraknCoreServer) DatabaseDelete(context.Context, *CoreDatabase_Delete_Req) (*CoreDatabase_Delete_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseDelete not implemented")
}
func (UnimplementedGraknCoreServer) SessionOpen(context.Context, *Session_Open_Req) (*Session_Open_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionOpen not implemented")
}
func (UnimplementedGraknCoreServer) SessionClose(context.Context, *Session_Close_Req) (*Session_Close_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionClose not implemented")
}
func (UnimplementedGraknCoreServer) SessionPulse(context.Context, *Session_Pulse_Req) (*Session_Pulse_Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionPulse not implemented")
}
func (UnimplementedGraknCoreServer) Transaction(GraknCore_TransactionServer) error {
	return status.Errorf(codes.Unimplemented, "method Transaction not implemented")
}
func (UnimplementedGraknCoreServer) mustEmbedUnimplementedGraknCoreServer() {}

// UnsafeGraknCoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GraknCoreServer will
// result in compilation errors.
type UnsafeGraknCoreServer interface {
	mustEmbedUnimplementedGraknCoreServer()
}

func RegisterGraknCoreServer(s grpc.ServiceRegistrar, srv GraknCoreServer) {
	s.RegisterService(&_GraknCore_serviceDesc, srv)
}

func _GraknCore_DatabasesContains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoreDatabaseManager_Contains_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).DatabasesContains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/databases_contains",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).DatabasesContains(ctx, req.(*CoreDatabaseManager_Contains_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_DatabasesCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoreDatabaseManager_Create_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).DatabasesCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/databases_create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).DatabasesCreate(ctx, req.(*CoreDatabaseManager_Create_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_DatabasesAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoreDatabaseManager_All_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).DatabasesAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/databases_all",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).DatabasesAll(ctx, req.(*CoreDatabaseManager_All_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_DatabaseSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoreDatabase_Schema_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).DatabaseSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/database_schema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).DatabaseSchema(ctx, req.(*CoreDatabase_Schema_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_DatabaseDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoreDatabase_Delete_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).DatabaseDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/database_delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).DatabaseDelete(ctx, req.(*CoreDatabase_Delete_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_SessionOpen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session_Open_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).SessionOpen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/session_open",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).SessionOpen(ctx, req.(*Session_Open_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_SessionClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session_Close_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).SessionClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/session_close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).SessionClose(ctx, req.(*Session_Close_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_SessionPulse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session_Pulse_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraknCoreServer).SessionPulse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grakn.protocol.GraknCore/session_pulse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraknCoreServer).SessionPulse(ctx, req.(*Session_Pulse_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _GraknCore_Transaction_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GraknCoreServer).Transaction(&graknCoreTransactionServer{stream})
}

type GraknCore_TransactionServer interface {
	Send(*Transaction_Server) error
	Recv() (*Transaction_Client, error)
	grpc.ServerStream
}

type graknCoreTransactionServer struct {
	grpc.ServerStream
}

func (x *graknCoreTransactionServer) Send(m *Transaction_Server) error {
	return x.ServerStream.SendMsg(m)
}

func (x *graknCoreTransactionServer) Recv() (*Transaction_Client, error) {
	m := new(Transaction_Client)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GraknCore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grakn.protocol.GraknCore",
	HandlerType: (*GraknCoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "databases_contains",
			Handler:    _GraknCore_DatabasesContains_Handler,
		},
		{
			MethodName: "databases_create",
			Handler:    _GraknCore_DatabasesCreate_Handler,
		},
		{
			MethodName: "databases_all",
			Handler:    _GraknCore_DatabasesAll_Handler,
		},
		{
			MethodName: "database_schema",
			Handler:    _GraknCore_DatabaseSchema_Handler,
		},
		{
			MethodName: "database_delete",
			Handler:    _GraknCore_DatabaseDelete_Handler,
		},
		{
			MethodName: "session_open",
			Handler:    _GraknCore_SessionOpen_Handler,
		},
		{
			MethodName: "session_close",
			Handler:    _GraknCore_SessionClose_Handler,
		},
		{
			MethodName: "session_pulse",
			Handler:    _GraknCore_SessionPulse_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "transaction",
			Handler:       _GraknCore_Transaction_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v2/protobuf/core/core_service.proto",
}
